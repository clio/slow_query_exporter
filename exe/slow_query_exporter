#!/usr/bin/env ruby
require 'gelf'
require 'pentagram'
require 'slow_query_exporter'
require 'syslog'

module SlowQueryExporter
  class Daemon < Pentagram::Daemon
    # CHUNK_SIZE defines the maximum amount of data that will be read from our slow query log during each main loop
    # iteration. We may get _less_ data than this, but we'll never get _more_ data than this. The data read may contain
    # any number of complete lines (anywhere from 0 to N).
    CHUNK_SIZE = 8192

    def initialize
      super

      option_parser.banner = "#{File.basename(__FILE__)} [-dv] [--sleep delay] [-h host] [-p port] [options] /path/to/slow_query.log"
      option_parser.version = SlowQueryExporter::VERSION
      option_parser.summary_width = 22

      options[:gelf_host] ||= "localhost"
      option_parser.on(
        "-h HOST", "--host HOST",
        "The GELF host (default: #{options[:gelf_host]})"
      ) do |host|
        options[:gelf_host] = host
      end

      options[:gelf_port] ||= 12201
      option_parser.on(
        "-p PORT", "--port PORT", Integer,
        "The GELF UDP port (default: #{options[:gelf_port]})"
      ) do |port|
        raise OptionParser::InvalidArgument.new("port must be above zero") unless port > 0
        options[:gelf_port] = port
      end

      options[:state_path] ||= "/var/lib/slow_query_exporter/last_timestamp"
      option_parser.on(
        "-s PATH", "--state PATH",
        "The path to the file to be used for daemon state storage (default: #{options[:state_path]})."
      ) do |path|
        options[:state_path] = path
      end

      Syslog.open(File.basename(__FILE__), Syslog::LOG_PID | Syslog::LOG_PERROR, Syslog::LOG_DAEMON)
    end

    def parse_arguments!
      super
      parent = File.dirname(options[:state_path])
      unless File.exist?(parent)
        raise OptionParser::InvalidArgument.new("--state #{options[:state_path]} - directory #{parent} does not exist")
      end
      raise OptionParser::MissingArgument.new("/path/to/slow_query.log is required") if ARGV.empty?
      raise OptionParser::InvalidArgument.new("#{ARGV.slice(1, ARGV.size).join(' ')}") if ARGV.size > 1
    end

    def hook_pre_main
      @current_timestamp = begin
        IO.read(options[:state_path]).to_i
      rescue Errno::ENOENT
        0
      end
      @gelf = GELF::Notifier.new(options[:gelf_host], options[:gelf_port], "WAN")
      @input_buffer = []
      @parser = SlowQueryExporter::QueryParser.new
      @tail = IO.popen(["tail", "-F", "-n", "+0", ARGV[0]])
      trap("EXIT") { Process.kill("INT", @tail.pid) if @tail }
    end

    def hook_main
      begin
        ready_io = Pentagram::SignalBroker.select([@tail])
        if ready_io && ready_io.first && ready_io.first.include?(@tail)
          chunk = @tail.read_nonblock(CHUNK_SIZE)
          @input_buffer.concat(chunk.split(/(?<=#{$/})/))
        end
      rescue EOFError
        @@continue = false
      end
      while @input_buffer.length > 0
        until @input_buffer[0].end_with?($/)
          # Break out of this iteration of our main loop (returning to read more data) if we don't yet have a complete
          # line and we have no further data pending concatenation to our string.
          return if @input_buffer.length < 2
          @input_buffer[0] += @input_buffer.delete_at(1)
        end
        line = @input_buffer.shift
        # The MySQL slow query log is stored as UTF-8, but since we have read from the file as a binary operation (not
        # as a string operation), our data is ASCII-8BIT. Force it to recognize itself as a UTF-8 string.
        line.force_encoding("utf-8")
        @parser.parse_line(line)
        while query = @parser.pop_finished_query
          if query.timestamp >= @current_timestamp
            @current_timestamp = query.timestamp
            File.open(options[:state_path], "w") { |f| f.puts(@current_timestamp) }
            puts query.gelf_attributes.inspect, "\n" if options[:verbose]
            @gelf.notify!(query.gelf_attributes)
          end
        end
      end
    end
  end
end

SlowQueryExporter::Daemon.new.run

#!/usr/bin/env ruby

require 'daemons'
require 'gelf'
require 'optparse'
require 'syslog'
require 'slow_query_exporter'

RUN_DIRECTORY = "/var/run/slow_query_exporter"
LIB_DIRECTORY = "/var/lib/slow_query_exporter"
PROGRESS_FILE = "#{LIB_DIRECTORY}/last_timestamp"

$gelf_host = "localhost"
$gelf_port = 12201
$delay = 0.1
$verbose = false
$foreground = false

opts = OptionParser.new do |opts|
  opts.banner = "Usage: slow_query_exporter [-fv] [-d delay] [-h host] [-p port] /path/to/slow_query.log"
  opts.version = SlowQueryExporter::VERSION
  opts.summary_width = 22
  opts.on("-d SECONDS", "--delay SECONDS", Float, "An interval to pause after each GELF message, in (possibly fractional) seconds (default: #{$delay}s)") { |delay| $delay = delay.to_f }
  opts.on("-f", "--foreground", "Don't daemonize on startup") { $foreground = true }
  opts.on("-?", "--help", "Display this help text") do
    puts(opts)
    exit
  end
  opts.on("-h HOST", "--host HOST", "The GELF host (default: #{$gelf_host})") { |host| $gelf_host = host }
  opts.on("-p PORT", "--port PORT", Integer, "The GELF UDP port (default: #{$gelf_port})") { |port| $gelf_port = port }
  opts.on("-v", "--[no-]verbose", "Print entries to stdout as they're parsed") { $verbose = true }
  opts.on("--version", "Display application version information") do
    puts(opts.version)
    exit
  end
end
begin
  opts.parse!
  raise OptionParser::MissingArgument.new("/path/to/slow_query.log is required") if ARGV.empty?
  raise OptionParser::InvalidArgument.new("#{ARGV.slice(1, ARGV.size).join(' ')}") if ARGV.size > 1
rescue OptionParser::InvalidOption, OptionParser::InvalidArgument, OptionParser::MissingArgument => e
  $stderr.puts(e)
  $stderr.puts
  $stderr.puts(opts)
  exit 2
end

Daemons.daemonize(ontop: $foreground, app_name: "slow_query_exporter", dir_mode: :normal, dir: RUN_DIRECTORY)
Syslog.open("slow_query_exporter", Syslog::LOG_PID | Syslog::LOG_PERROR, Syslog::LOG_DAEMON)
last_timestamp = begin
                   IO.read(PROGRESS_FILE).to_i
                 rescue Errno::ENOENT
                   0
                 end

logfile = ARGV[0]
gelf = GELF::Notifier.new($gelf_host, $gelf_port, "WAN")
parser = SlowQueryExporter::QueryParser.new

begin
  tail = IO.popen(["tail", "-F", "-n", "+0", logfile])
  tail.each_line do |line|
    parser.parse_line(line)
    while query = parser.pop_finished_query
      if query.timestamp >= last_timestamp
        last_timestamp = query.timestamp
        File.open(PROGRESS_FILE, "w") { |f| f.puts(last_timestamp) }

        puts query.gelf_attributes.inspect, "\n" if $verbose
        gelf.notify!(query.gelf_attributes)
        sleep $delay    # avoids swamping the Graylog server
      end
    end
  end

ensure
  Process.kill("INT", tail.pid) if tail
end

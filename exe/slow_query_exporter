#!/usr/bin/env ruby
require 'gelf'
require 'pentagram'
require 'slow_query_exporter'
require 'syslog'

module SlowQueryExporter
  class Daemon < Pentagram::Daemon
    def initialize
      super

      option_parser.banner = "#{File.basename(__FILE__)} [-dv] [--sleep delay] [-h host] [-p port] [options] /path/to/slow_query.log"
      option_parser.version = SlowQueryExporter::VERSION
      option_parser.summary_width = 22

      options[:gelf_host] ||= "localhost"
      option_parser.on(
        "-h HOST", "--host HOST",
        "The GELF host (default: #{options[:gelf_host]})"
      ) do |host|
        options[:gelf_host] = host
      end

      options[:gelf_port] ||= 12201
      option_parser.on(
        "-p PORT", "--port PORT", Integer,
        "The GELF UDP port (default: #{options[:gelf_port]})"
      ) do |port|
        raise OptionParser::InvalidArgument.new("port must be above zero") unless port > 0
        options[:gelf_port] = port
      end

      options[:state_path] ||= "/var/lib/slow_query_exporter/last_timestamp"
      option_parser.on(
        "-s PATH", "--state PATH",
        "The path to the file to be used for daemon state storage (default: #{options[:state_path]})."
      ) do |path|
        options[:state_path] = path
      end

      Syslog.open(File.basename(__FILE__), Syslog::LOG_PID | Syslog::LOG_PERROR, Syslog::LOG_DAEMON)
    end

    def parse_arguments!
      super
      parent = File.dirname(options[:state_path])
      unless File.exist?(parent)
        raise OptionParser::InvalidArgument.new("--state #{options[:state_path]} - directory #{parent} does not exist")
      end
      raise OptionParser::MissingArgument.new("/path/to/slow_query.log is required") if ARGV.empty?
      raise OptionParser::InvalidArgument.new("#{ARGV.slice(1, ARGV.size).join(' ')}") if ARGV.size > 1
    end

    # Read a line of input (with a 'line' as defined by the separator argument) from the given file descriptor. If
    # <timeout> seconds expire before enough data is available to return a line of data, raises IO::WaitReadable. Note
    # that timeout is only enforced when the method is waiting for more data, which means that if the method is busy
    # reading a _very_ long line of data, the entire execution may take longer than <timeout> seconds.
    private def gets_with_timeout(fd, timeout, separator: $/)
      @gets_buffer ||= []
      timeout = Time.now.to_f + timeout
      begin
        while byte = fd.read_nonblock(1)
          @gets_buffer << byte
          if byte == separator
            line = @gets_buffer.join('')
            @gets_buffer.clear
            return line
          end
        end
      rescue EOFError
        if @gets_buffer.size > 0
          line = @gets_buffer.join('')
          @gets_buffer.clear
          return line
        end
        return nil
      rescue IO::WaitReadable
        now = Time.now.to_f
        raise if now >= timeout
        raise if IO.select([fd], nil, nil, timeout - now).nil?
        retry
      end
    end

    def hook_pre_main
      @current_timestamp = begin
        IO.read(options[:state_path]).to_i
      rescue Errno::ENOENT
        0
      end
      @gelf = GELF::Notifier.new(options[:gelf_host], options[:gelf_port], "WAN")
      @tail = IO.popen(["tail", "-F", "-n", "+0", ARGV[0]])
      @parser = SlowQueryExporter::QueryParser.new
    end

    def hook_main
      begin
        line = gets_with_timeout(@tail, 0.1)
        if line.nil?
          @@continue = false
          return
        end
        @parser.parse_line(line)
        while query = @parser.pop_finished_query
          if query.timestamp >= @current_timestamp
            @current_timestamp = query.timestamp
            File.open(options[:state_path], "w") { |f| f.puts(@current_timestamp) }
            puts query.gelf_attributes.inspect, "\n" if options[:verbose]
            @gelf.notify!(query.gelf_attributes)
          end
        end
      rescue IO::WaitReadable
      end
    end

    def hook_post_main
      Process.kill("INT", @tail.pid) if @tail
    end
  end
end

SlowQueryExporter::Daemon.new.run
